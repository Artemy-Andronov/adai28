\documentclass[12pt]{article}
\usepackage{config}
\usepackage{subfiles}
\pgfplotsset{compat=1.18}

\begin{document}

\begin{flushright}
    Конспект Шорохова Сергея

    Если нашли опечатку/ошибку - пишите @le9endwp 
\end{flushright}

\tableofcontents
\newpage

\section{Лекция 1. Введение в реляционные базы данных}

\subsection{Понятие базы данных и СУБД}

\begin{defin}{Данные}
    Данные -- факты, текст, графики, картинки, звуки, аналоговые или цифровые видео-сегменты, представленные в форме, пригодной для хранения,  передачи и обработки
\end{defin}

\begin{nota}{Задачи технологий работы с данными}
    \begin{itemize}
        \item Загрузить 
        \begin{itemize}
            \item Получить
            \item Передать между системами
            \item Собрать в одном месте
        \end{itemize}
        \item Сохранить 
        \begin{itemize}
            \item Обеспечить эффективное безопасное хранение
            \item Предоставить доступ
            \item Обеспечить быстрый поиск
        \end{itemize}
        \item Обработать
        \begin{itemize}
            \item Объединить в одной структуре
            \item Рассчитать показатели
            \item Обработать модель
        \end{itemize}
        \item Принять решение
        \begin{itemize}
            \item Отчеты
            \item Дашборды
            \item Визуализация
            \item Предписание в операционном процессе
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{nota}{Что должны обеспечивать системы обработки данных?}
    \begin{itemize}
        \item Поддержку необходимых требований к данными
        \begin{itemize}
            \item Сохранность и достоверность данных в соответствии со спецификой предметной области
            \item Защиту от искажения, уничтожения данных и несанкционированного доступа
            \item Простоту и легкость использования данных
            \item Требуемую скорость доступа к данным
        \end{itemize}
        \item Независимость прикладных программ от данных 
        \begin{itemize}
            \item Возможность использования одних и тех же данных различными приложениями
            \item Изменение логического представления данных (добавление/удаление новых элементов данных) не должно приводить к изменению прикладных программ обработки
            \item Изменение параметров физической организации данных (характеристик носителя, длины блока, и др.) или методов доступа к ним не должны приводить к изменению прикладных программ
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Независимость (от) данных}
    \begin{itemize}
        \item \textbf{Логическая}
        
        Изменение логического представления данных (добавление/удаление новых элементов данных, разделение на несколько логических сегментов, изменение порядка хранения) не должно приводить к изменению прикладных программ обработки
        \item \textbf{Физическая}
        
        Изменение параметров физической организации данных (характеристик носителя, длины блока, и др.) или методов доступа к ним не должны приводить к изменению логической структуры данных или прикладных программ их обработки            
    \end{itemize}
\end{defin}

\begin{nota}{Концепции обработки данных}
    \begin{itemize}
        \item \textbf{Файловая обработка данных}
        
        До середины 60-х годов прошлого века – основная концепция построения программного обеспечения обработки данных

        \item \textbf{Базы данных}
        
        Независимость прикладных программ от данных

        \item \textbf{Объектно-ориентированные базы данных}
        
        Независимость прикладных программ от данных вместе с процедурами их обработки (объектно-ориентированный подход в программировании)
    \end{itemize}
\end{nota}

\begin{Remark}{Файловая обработка данных}
    \begin{itemize}
        \item Совмещение логического и физического представления данных
        \begin{itemize}
            \item Физически данные ИС размещаются в файлах операционной системы
            \item Прикладные программы работают напрямую с файлами
            \item Структура файла зависит от требований конкретной прикладной программы, с ним работающей, и определяется разработчиком приложения
        \end{itemize}
        \item Зависимость программ обработки от организации данных
        \begin{itemize}
            \item Возможная избыточность и противоречивость данных 
            \item Для каждой задачи – свой алгоритм получения данных 
        \end{itemize}
        \item Разграничение доступа и защита данных – на уровне средств ОС
    \end{itemize}

    Она не обеспечивает:
    \begin{itemize}
        \item Поддержание логически согласованного набора файлов
        \item Единого языка манипулирования данными
        \item Восстановление информации после разного рода сбоев
        \item Реально параллельной работы нескольких пользователей
    \end{itemize}
\end{Remark}

\begin{Remark}{Базы данных}
    \begin{itemize}
        \item Разделение логического и физического представления данных
        \begin{itemize}
            \item Физически данные как правило размещаются в файлах операционной системы
            \item Разрабатывается определённая логическая структура данных, с которой «общаются» прикладные программы
            \item Логическая структура данных основана на физической, но не меняется при изменении последней
        \end{itemize}
        \item Независимость программ обработки от организации данных
        \begin{itemize}
            \item Сокращение избыточности и противоречивости данных
            \item Единые языки для получения и изменения данных
            \item Дополнительные средства разграничения доступа и защиты данных, учитывающие их логическую структуру
        \end{itemize}
    \end{itemize}
\end{Remark}

\begin{Remark}{Объектно-ориентированные БД}
    \begin{itemize}
        \item Разделение логического и физического представления данных
        \begin{itemize}
            \item Физические данные как правило размещаются в файлах операционной системы
            \item На логическом уровне данные представляют собой объекты
            \begin{itemize}
                \item Данные $\to$ свойства объекта (статическая часть)
                \item Обработка данных $\to$ методы объекта (динамическая часть)
            \end{itemize}
        \end{itemize}
        \item Независимость прикладных программ от объектов
        \item Концепция повторного использования программного кода
        \begin{itemize}
            \item Разные прикладные программы используют унифицированные методы обработки одних и тех же данных
        \end{itemize}
    \end{itemize}
\end{Remark}

\newpage

\subsection{Базы данных и СУБД}

\begin{defin}{База данных}
    База данных -- логически структурированная совокупность постоянно хранимых в памяти компьютера данных, характеризующих актуальное состояние некоторой предметной области и используемых прикладными программными системами какого-либо предприятия

    База данных (БД) -- совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных (ГОСТ)
\end{defin}

\begin{nota}{Основные характеристики БД}
    \begin{itemize}
        \item Компьютерная система -- БД хранится и обрабатываемя в вычислительной системе
        \item Содержит структурированную информацию -- данные в БД логически структурированы (систематизированы) с целью обеспечения возможности их эффективного поиска и обработки в вычислительной системе 
        \begin{itemize}
            \item Структурированность БД оценивается не на уровне физического хранения, а на уровне некоторой логической модели данных
        \end{itemize}
        \item Поддерживает определенный набор операций над данными 
        \begin{itemize}
            \item Структурированность определяет семантику и допустимые операции
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Система баз данных (банк данных)}
    База данных является составной частью системы баз данных 

    Система базы данных -- компьютеризированная система обработки данных, хранящихся в БД

    Основные функции системы баз данных:

    \begin{itemize}
        \item Добавление новых структур данных (таблиц) в базу данных
        \item Изменение существующих структур данных (таблиц)
        \item Добавление новых элементов данных (записей в таблицы)
        \item Выборка необходимых элементов данных (записей из таблиц)
        \item Обновление элементов данных (записей в таблицах)
        \item Удаление элементов данных (записей из таблиц)
        \item Удаление структур данных (таблиц) из базы данных 
    \end{itemize}
\end{defin}

\begin{defin}{Системы управления базами данных}
    СУБД -- совокупность программных средств, предназначенная для модификации и извлечения из БД необходимых пользователю (прикладной программе) данных, а также для создания БД, поддержания их в работоспособном состоянии, обеспечения безопасности БД и решения других задач администрирования

    \textbf{Цель:} Обеспечивать совместное безопасное использование данных различными приложениями и пользователями

    Основные функции СУБД:

    \begin{itemize}
        \item Обеспечение физической и логической независимости данных
        \item Поддержка связи между логической и физической организацией данных
        \item Предоставление интерфейса доступа к данным пользователям и прикладным программам
        \item Обеспечение целостности и непротиворечивости данных при совместной работе нескольких пользователей
        \item Предоставление механизмов защиты данных
        \item Предоставление механизмов восстановления данных
    \end{itemize}
\end{defin}

\begin{nota}{Обеспечение логической и физической независимости данных}
    СУБД обеспечивает необходимые структуры внешней памяти как для хранения пользовательских данных БД, так и для служебных целей

    СУБД скрывает от пользователей как используется файловая система и как организованы файлы

    Для связи логической и физической структур данных СУБД использует служебную (мета) информация, хранящуюся в словаре данных
\end{nota}

\begin{nota}{Управление буферами оперативной памяти}
    Для увеличения скорости обработки данных используется буферизация данных в оперативной памяти

    СУБД поддерживает собственный набор буферов оперативной памяти с собственным алгоритмом замены буферов
\end{nota}

\begin{nota}{Предоставление интерфейса доступа к данным}
    Для работы с базами данных СУБД предоставляет поддержку специальных языков, называемых языками баз данных

    \begin{itemize}
        \item Язык описания данных (DDL) -- позволяет создавать и изменять структуру объектов базы данных
        \item Язык манипулирования данными (DML) -- позволяет заносить данные в БД, удалять, модифицировать или выбирать существующие данные
    \end{itemize}

    Использование данных языков позволяет пользователям сохранять, извлекать и обновлять данные в БД без необходимости понимания физической реализации системы
\end{nota}

\begin{nota}{Обеспечение целостности}
    Целостность БД -- свойство БД, означающее, что в ней содержится полная, непротиворечивая и адекватно отражающая предметную область информация 

    Целостность данных предполагает:
    
    \begin{itemize}
        \item Отсутствие неточно введенных данных или двух одинаковых записей об одном и том же факте
        \item Защиту от ошибок при обновлении данных в БД
        \item Невозможность удаления (или каскадное удаление) записей, которые связаны с другими записями
        \item Неискажение данных при работе в многопользовательском режиме
        \item Сохранность данных при сбоях техники (восстановление данных)
    \end{itemize}

    СУБД должна обладать инструментами контроля за тем, чтобы данные и их изменения соответствовали заданным правилам 
\end{nota}

\begin{nota}{Управление параллельной работой пользователей}
    Для управления параллельной работой пользователей и поддержки целостности данных в СУБД реализован механизм изоляции транзакций
\end{nota}

\begin{defin}{Транзакция}
    Транзакция -- некоторая неделимая последовательность операций над данными БД, которая отслеживается СУБД от начала и до завершения

    Если по каким-либо причинам (сбои и отказы оборудования, ошибки в программном обеспечении) транзакция остается незавершенной или при выполнении транзакции нарушается целостность данных, то она отменяется
\end{defin}

\begin{defin}{Журнализация}
    СУБД должна иметь возможность восстановить последнее согласованное состояние БД после любого аппаратного или программного сбоя 

    Для восстановления БД нужно располагать некоторой дополнительной информацией, которая должна храниться особо надежно

    Наиболее распространенным методом поддержания такой избыточной информации является ведение журнала изменений БД -- журнала транзакций
\end{defin}

\begin{nota}{Обеспечение безопасности БД}
    СУБД должна иметь механизм, гарантирующий возможность доступа к базе данных только санкционированных пользователей

    Термин безопасность относится к защите БД от преднамеренного или случайного несанкционированного доступа

    Защита данных от несанкционированного доступа может достигаться:

    \begin{itemize}
        \item Созданием ролей и ввдеением системы паролей
        \item Настройкой разрешений на доступ к данным и выполнение операций с данными
        \item Шифрованием соединения с прикладными программами
        \item Шифрованием данных 
    \end{itemize}
\end{nota}

\begin{nota}{Выбор СУБД}
    Выбор СУБД -- важный шаг при создании ИС, влияющий на эффективность, как проектирования, так и функционирования системы

    Учитывая тенденции развития ИС, СУБД должна отвечать следующим требованиям:

    \begin{itemize}
        \item Обеспечивать работу в гетерогенной сетевой среде, включая возможность эффективной работы в Интернете
        \item Легко переноситься с платформы на платформу
        \item Обеспечивать работу с большими объемами разнотипных данных
        \item Быть надежной и эффективной
    \end{itemize}
\end{nota}

\newpage

\subsection{Принципы организации базы данных}

\begin{nota}{Требования к БД и СУБД}
    \begin{itemize}
        \item Высокое быстродействие (малое время отклика на запрос)
        \item Простота обновления данных
        \item Защита данных от преднамеренного или непреднамеренного нарушения секретности, искажения или разрушения
        \item Поддержка целостности данных
        \item Независимость данных -- возможность изменения логической и физической структуры БД без изменения предсталвений пользователей
        \item Совместное использование данных многими пользователями
        \item Стандартизация построения и эксплуатации БД
        \item Адекватность отображения данных соответствующей предметной области 
    \end{itemize}
\end{nota}

\begin{nota}{Принципы организации БД}
    \begin{itemize}
        \item Разделение различных видов данных
        \begin{itemize}
            \item Данные пользовательские (приложений)
            \item Вспомогательные данные (индексы)
            \item Метаданные (словарь данных БД)
            \item Служебная информация
        \end{itemize}
        \item Позволяет повысить безопасность данных и быстродействие работы с ними
        \item Проектирование логической структуры данных 
        
        Выбор модели данных (в зависимости от требований доступа к данным)

        \item Позволяет обеспечить: 
        \begin{itemize}
            \item Логическую и физическую независимость данных 
            \item Адекватность отображения данных соответствующей предметной области 
            \item Удобство работы и гибкость
        \end{itemize}
        \item Определение ограничений данных 
        \begin{itemize}
            \item Уменьшение ошибок ввода/изменения данных 
            \item Зависимость от семантики данных
        \end{itemize}
        \item Позволяет поддержать целостность данных 
    \end{itemize}
\end{nota}

\subsection{Реляционная модель данных}

\begin{defin}{Модель данных}
    Модель данных -- формальное описание представления и обработки данных в системе управления базами данных
\end{defin}

\begin{nota}{Компоненты реляционной модели данных}
    \begin{itemize}
        \item Структурный аспект 
        
        \begin{itemize}
            \item Какие структуры данных рассматриваются реляционной моделью 
            \item Постулируется, что единственной структурой данных, используемой в реляционной модели, являются нормализованные $n$-арные отношения
        \end{itemize}

        \item Аспект целостности 
        
        \begin{itemize}
            \item Ограничения специального вида, которые должны выполняться для любых отношений в любых реляционных базах данных 
            \item Целостность сущностей реального мира 
            \item Ссылочная целостность 
        \end{itemize}

        \item Аспект обработки 
        
        \begin{itemize}
            \item Способы манипулирования реляционными данными
            \item Реляционная алгебра -- базируется на теории множеств
            \item Реляционное исчисление -- базируется на логическом аппарате исчисления предикатов первого порядка 
        \end{itemize}
    \end{itemize}
\end{nota}

\newpage

\subsection{Структурный аспект реляционной модели}

\begin{defin}{Отношение}
    Отношение (relation) -- класс объектов реального мира, каждый из которых должен быть уникально идентифицирован

    \begin{itemize}
        \item Подмножество $R$ декартового произведения множеств элементов доменов: (не обязательно различных)
        \item Или множество кортежей, соответствующих одной схеме отношения 
        \item Мощность отношения -- количество кортежей в отношении
        \item На бытовом уровне -- тело таблицы
    \end{itemize}
\end{defin}

\begin{defin}{Схема отношения}
    \begin{itemize}
        \item Именованное конечное множество пар вида $\{$Имя\_атрибута: Имя\_домена$\}$
        \item Степень или -арность (схемы) отношения -- количество атрибутов
        \item На бытовом уровне -- заголовок таблицы 
    \end{itemize}
\end{defin}

\begin{defin}{Атрибут}
    Атрибут (поле, столбец) -- характеристика объекта, принимающая значения определенного типа данных 

    \begin{itemize}
        \item Подмножество домена (атрибут $A_n$ определен на домене $D_n$, который содержит множество возможных значений атрибута)
        
        $A_1(D_1), A_2(D_2), \ldots A_n(D_n)$

        \item На бытовом уровне -- столбец таблицы 
        \item Имена атрибутов должны быть уникальны в пределах отношения 
    \end{itemize}
\end{defin}

\begin{defin}{Тип данных}
    Тип данных -- реляционная модель данных допускает использование только простых типов 

    \begin{itemize}
        \item Соответствует понятию типа данных в языках программирования 
        \item Реляционная модель данных допускает использование только простых типов (логические, символьные, числовые \dots), т.к. в реляционных операциях не должна учитываться внутренняя структура данных 
    \end{itemize}
\end{defin}

\begin{defin}{Домен}
    Домен -- произвольное логическое выражение (опционально), определяющее набор допустимых значений атрибута 

    \begin{itemize}
        \item Базовый тип данных + произвольное логическое выражение (опционально)
        \item Если вычисление заданного логического выражения для элемента данных заданного типа дает результат "истина"\ , то он является элементом домена
        \item Домены ограничивают сравнения: некорректно, с логической точки зрения, сравнивать значения из различных доменов, даже если они имеют одинаковый тип данных (например, возраст сотрудника и количество его детей)
    \end{itemize}
\end{defin}

\begin{defin}{Кортеж}
    Кортеж (запись, строка) -- набор связанных значений атрибутов, относящихся к одному объекту (сущности)

    \begin{itemize}
        \item Множества пар вида $\{$ Имя\_атрибута: Значение\_атрибута $\}$
        \item На бытовом уровне -- строка таблицы 
        \item Значение атрибута должно быть в пределах заданного домена
        \item Каждый кортеж отношения должен быть уникально идентифицирован
    \end{itemize}
\end{defin}

\begin{defin}{Схема БД}
    Схема БД (в структурном смысле) -- набор именованных схем отношений 
\end{defin}

\begin{defin}{Реляционная база данных}
    Реляционная база данных -- набор отношений, имена которых совпадают с именами схем отношений в схеме БД
\end{defin}

\begin{nota}{Свойства отношений}
    \begin{itemize}
        \item В отношении нет кортежей-дубликатов
        
        Т.к. отношение -- это множество кортежей, а каждое множество (в классической теории множеств) состоит из различных элементов 

        Во многих РСУБД может нарушаться для отношений, являющихся результатами запросов

        \item Кортежи не упорядочены
        
        Множество не упорядочено

        \item Атрибуты не упорядочены 
        
        Каждый атрибут имеет уникальное имя в пределах отношения, поэтому порядок атрибутов не имеет значения 

        \item Значение атрибута должно быть атомарным (неразделяемым на несколько значений)
        
        В современных РСУБД в ячейки таблиц можно поместить что угодно -- массивы, структуры и даже другие таблицы 

        \item Домены ограничивают сравнения
        
        Некорректно, с логической точки зрения, сравнивать значения из различных доменов, даже если они имеют одинаковый тип данных 
    \end{itemize}
\end{nota}

\newpage

\subsection{Аспект целостности реляционной модели}

\begin{defin}{Целостность базы данных}
    Целостность базы данных (database integrity) -- соответствие имеющейся в базе данных информации ее внутренней логике, структуре и всем явно заданным правилам 

    Каждое такое правило, налагающее ограничение на возможное состояние базы данных, называется ограничением целостности (integrity constraint)

    Задача аналитика и проектировщика БД -- возможно более полно выявить все имеющиеся ограничения целостности и задать их в базе данных 

    СУБД может (и должна) контролировать целостность БД
\end{defin}

\begin{nota}{Сущностная целостность}
    Каждый кортеж отношения должен быть уникально идентфиицирован по значениям его атрибутов

    Потенциальный ключ обладает следующими свойствами:

    \begin{itemize}
        \item Свойством уникальности -- в отношении не моежт быть двух различных кортежей с одинаковым значением потенциального ключа
        \item Свойством неизбыточности -- никакое подмножество в потенциальном ключе не обладает свойством уникальности, т.к. если из потенциального ключа убрать любой атрибут, он утратит свойство уникальности
    \end{itemize}

    Отношение может иметь несколько потенциальных ключей:

    \begin{itemize}
        \item Один из потенциальных ключей объявляется первичным -- Primary Key, а остальные -- альтернативными -- Alternate Key
        \item С точки зрения реляционной модели данных, нет оснований выделять таким образом один из потенциальных ключей 
    \end{itemize}
\end{nota}

\begin{nota}{Правила для поддержки сущностной целостности}
    Потенциальный ключ может быть:

    \begin{itemize}
        \item Простым -- состоит из одного атрибута 
        \item Составным -- состоит из нескольких атрибутов 
    \end{itemize}

    Потенциальные ключи фактически являются идентификаторами. Если бы идентификаторы могли содержать NULL значения, невозможно было бы дать ответ "да"\ или "нет"\ на вопрос, совпдаают ли два идентификатора 

    Это определяет следующее правило: значения атрибутов, входящих в состав некоторого потенциального ключа не могут быть NULL (во многих СУБД выполняется только для первичного ключа)
\end{nota}

\begin{defin}{NULL}
    Для того чтобы обойти проблему неполных или неизвестных данных, каждый тип данных в БД может быть дополнен NULL

    NULL -- это не значение, а некий маркер, показывающий, что значение неизвестно 

    В ситуации, когда возможно появление неизвестных или неполных данных, разработчик имеет на выбор два варианта: 

    \begin{itemize}
        \item Ограничиться использованием обычных типов данных и не использовать NULL, а вместо неизвестных данных вводить либо нулевые значения, либо значения специального вида 
        \item Использовать NULL вместо неизвестных данных 
    \end{itemize}

    Наличие NULL приводит к использованию трехзначной логики:

    \begin{itemize}
        \item Три возможных значений выражений: TRUE (T), FALSE (F), UNKNOWN (U)
        \item NULL = NULL $\to$ U (NOT NULL = NULL $\to$ U)
        \item NULL !+ NULL $\to$ U (NOT NULL != NULL $\to$ U)
        \item F OR NULL $\to$ U (T OR NULL $\to$ T)
        \item T AND NULL $\to$ U (F AND NULL $\to$ F)
    \end{itemize}
\end{defin}

\begin{defin}{Внешние ключи}
    Различные объекты предметной области, информация о которых хранится в базе данных, взаимосвязаны друг с другом 

    Для реализации взаимосвязи между родительским и дочерним отношениями в реляционных БД используются внешние ключи -- foreign key (FK)
\end{defin}

\begin{nota}{Требования к FK}
    Подмножество атрибутов FK отношения R будем называть внешним ключом, если 

    \begin{itemize}
        \item Существует отношения S (R и S не обязательно различны) с потенциальным ключом K
        \item Каждое значение FK в отношении R всегда совпадает со значением K для некоторого кортежа из S, либо является NULL
    \end{itemize}
\end{nota}

\begin{Remark}{Замечания относительно FK}
    \begin{itemize}
        \item Отноешние S называется родиетльским отношением, отношение R называется дочерним отношением
        \item FK, также как и потенциальный, может быть простым и Составным
        \item FK должен быть определен на тех же доменах, что и соответствующих потенциальный ключ родительского отношения
        \item FK, как правило, не обладает свойством уникальности (тип связи -- один ко многим)
        \item Для FK не требуется, чтобы он был компонентом некоторого потенциального ключа
        \item NULL для значений атрибутов FK допустимы только в том случае, когда атрибуты FK не входят в состав никакого потенциального ключа 
    \end{itemize}
\end{Remark}

\begin{defin}{Связь}
    Связь -- ассоциирование двух или более сущностей (или копий одной и той же сущности)

    Одно из основным требований к организации БД -- это обеспечение возможности поиска одних сущностей по значениям других, для чего необходимо установить между ними определенные связи 

    Типы связей:

    \begin{itemize}
        \item Связь 1:1. Один экземпляр сущности одного класса связан с одним экземпляром сущности другого класса
        \item Связь 1:M. Один экземпляр сущности одного класса связан со многими экземплярами сущности другого класса 
        \item Связь M:N. Несколько экземпляров сущности одного класса связаны с несколькими экземплярами сущности другого класса
    \end{itemize}
\end{defin}

\begin{nota}{Допустимая кратность связей}
    В реляционных БД допустимыми являются связи типа 1:M и 1:1 (значения внешнего ключа -- уникальны)

    Механизм реализации допустимых взаимосвязей состоит в том, что на дочернее отношение добавляются атрибуты, являющиеся ссылками на ключевые атрибуты родительского отношения 

    Невозможно ссылаться на несуществующие объекты $\to$ значения атрибута внешнего ключа дочернего отношения должны иметь соответствие среди значений атрибутов отношения потенциального ключа родительского

    Взаимосвязи типа M:N реализуются использованием нескольких взаимосвязей типа 1:M
\end{nota}

\newpage

\subsection{Знакомство с PostreSQL (реклама)}

\begin{defin}{PostreSQL}
    PostreSQL -- это открытая, BSD-лицензированная система управления объектно-ориентированными реляционными базами данных 
\end{defin}

\begin{nota}{История PostreSQL}
    \begin{itemize}
        \item 1986 -- старт проекта PostreSQL на факультете компьютерных наук Калифорнийсокго университета в Беркли
        
        Первоначальное название проекта -- POSTGRES (развитие старой БД Ingres)

        \item 1996 -- проект POSTGRES переименован в PostreSQL, для отражения поддержки SQL
        
        Global Development Group PostreSQL, специализированное сообщество участников, продолжает выпускать релизы проекта с открытым исходным кодом 

        \item Первоначально PostreSQL был разарботан для работы на UNIX-подобных платформах
        
        Сейчас PostreSQL поддерживает различны платформы, такие как Windows, macOS и Solaris
    \end{itemize}
\end{nota}

\begin{nota}{Преимущества и особенности СУБД PostreSQL}
    \begin{itemize}
        \item Надежность
        \item Производительность
        \item Расширяемость
        \item Поддержка SQL
        \item Поддержка многочисленных типов данных
    \end{itemize}
\end{nota}

\begin{nota}{Расширяемость}
    PostreSQL спроектирован с рассчетом на расширяемость 

    Прикладные программисты могут:

    \begin{itemize}
        \item Создавать собственные типы данных на основе уже имеющихся (составные типы, диапазоны, масисвы, перечисления)
        \item Писать хранимые процедуры и функции для обработки данных в БД (в том числе триггеры)
        \item Писать расширения (языке программирования Си), которые добавляют необходимый функционал и, обычно, могут подключаться даже к работающему серверу
    \end{itemize}

    Если вам не нравится какая-либо часть системы, вы всегда можете разработать собственный плагин
\end{nota}

\begin{Remark}{Важный факт}
    Подавляющее большинство СУБД:

    \begin{itemize}
        \item Представляет собой сервис (демон в $^*$nix-системах), который взаимодействует с внешним миром по специальным протоколам (чаще всего, построенным поверх TCP/IP)
        \item Не имеет никакого человеческого интерфейса
        \item Общение осуществляется на специализированном языке через специальные библиотеки
    \end{itemize}

    MySQL Workbench, Microsoft SQL Serber Management Studio, Oracle SQL Developer и им подобные -- это не СУБД, это лишь клиентское программное обеспечение, позволяющее нам взаимодействовать с СУБД
\end{Remark}

\begin{nota}{Упрощенная архитектура PostreSQL}
    PostreSQL -- это СУБД клиент-серверного типа с многопроцессной архитектурой, работающая на одном хосте 

    Сбой в одном из процессов не повлияет на остальные и система продолжит функционировать 

    Набор нескольких процессов, совместно управляющих одним кластером БД, называется "сервером PostreSQL"\

    Один сервер PostreSQL может управлять несколькими конкурентными клиенсткими подключениями 
\end{nota}

\begin{nota}{Основные процессы}
    \begin{itemize}
        \item FrontEnd процессы -- клиентские приложения:
        
        \begin{itemize}
            \item Используют PostreSQL в качестве менеджера баз данных
            \item Соединение может происходить через TCP/IP или локальные сокеты 
        \end{itemize}

        \item Демон postres (postmaster) -- это основной процесс PostreSQL:
        
        \begin{itemize}
            \item Прослушивание через порт/сокет входящих клиенстких подключений
            \item Создание BackEnd процессов и выделение им ресурсов
        \end{itemize}

        \item BackEnd процессы:
        
        \begin{itemize}
            \item Аутентификация клиенстких подключений 
            \item Управление запросами и отправка результатов клиенстким приложениям 
            \item Выполнение внутренних задач (служебные процессы)
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{nota}{Процесс взаимодействия с БД}
    \begin{enumerate}
        \item Клиент (FrontEnd)
        
        \begin{enumerate}
            \item Используя язык БД формулирует требования к результату
            \item Опирается на знание логической структуры БД
        \end{enumerate}

        \item СУБД (postmaster и BackEnd)
        
        \begin{enumerate}
            \item Получает запрос от клиента 
            \item Анализирует разрешения
            \item Анализирует и оптимизирует запрос 
            \item Создает план выполнения запроса, опираясь на знание физической структуры данных
            \item Выполняет запрос 
        \end{enumerate}
    \end{enumerate}
\end{nota}

\begin{nota}{Взаимодействие с БД}
    Для работы с реляционной СУБД существует два основных подхода:

    \begin{itemize}
        \item Работа с библиотекой, которая соответствует конкретной СУБД и позволяет использовать для работы с БД язык БД 
        \item Работа с ORM, которая использует объектно-ориентированный подход для работы с БД и автоматически генерирует код на языке БД 
    \end{itemize}
\end{nota}

\begin{nota}{Подключение к СУБД с использованием клиентской библиотеки}
    Строка подключения вклюает:

    \begin{itemize}
        \item Имя сервера БД (или IP адрес и порт)
        \item Имя базы данных
        \item Учетную запись пользователям
        \item И другие параметры, необходимые для установки исходного подключения 
    \end{itemize}
\end{nota}

\newpage

\subsection{SQL и NoSQL}

\begin{nota}{Модели данных}
    \begin{itemize}
        \item Иерархическая (файловая система)
        \item Сетевая (социальные сети)
        \item Документ-ориентированная (системах управления содержимым)
        \item Реляционная (банковские системы)
        \item Объектно-ориентированная (естественное отображение ООП кода на БД, уменьшающее impedance mismatch)
        \item Многомерная (аналитические системы)
    \end{itemize}
\end{nota}

\begin{nota}{Преимущества РБД}
    \begin{itemize}
        \item Совместное использование данных
        
        \begin{itemize}
            \item Улучшенное управление паралелльной работой
            \item Повышенная безопасность 
            \item Контроль доступа к данным 
        \end{itemize}

        \item Поддержка целостности данных 
        
        \begin{itemize}
            \item Контроль за избыточностью данных и их непротиворечивостью
            \item Обеспечение поддержки бизнес-правил 
        \end{itemize}

        \item Эффективное управление 
        
        \begin{itemize}
            \item Упрощение сопровождения системы за счет неазависимости от данных 
            \item Эффективное резервное копирование и восстановление данных
        \end{itemize}

        \item Применение стандартов 
    \end{itemize}
\end{nota}

\begin{nota}{Недостатки РБД}
    \begin{itemize}
        \item Сложность
        
        Затраты на преобразование данных на входе и выходе

        \item Уязвимость
        
        Централизация ресурсов повышает уязвимость системы 

        \item Высокие финансовые затраты 
        
        \begin{itemize}
            \item Стоимость СУБД 
            \item Стоимость сопровождения 
            \item Дополнительные затраты на аппаратное обеспечение 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Базы данных NoSQL}
    Базы данных NoSQL хорошо подходят для приложений, которые должны быстро, с низкой временной задержкой (low latency) обрабатывать большой объем данных с разной структурой 

    \begin{itemize}
        \item Гибкость. Благодаря использованию гибких моделей данных БД NoSQL хорошо подходят для частично структурированных и неструктурированных данных. Эффективность работы с разреженными данными 
        \item Масштабируемость. БД NoSQL рассчитаны на масштабирование с использованием распределенных кластеров аппаратного обеспечения. Широко используются в облачных решениях в качестве полностью управляемых сервисов
        \item Высокая производительность. БД NoSQL оптмизированы для конкретных моделей данных и шаблонов доступа, что позволяет достичь более высокой производительности по сравнению с реляционными базами данных 
        \item Широкие функциональные возможности. БД NoSQL предоставляют API и типы данных с широкой функциональностью, которые специально разработаны для соответствующих моделей данных 
    \end{itemize}
\end{defin}

\begin{defin}{Нереляционные БД}
    \begin{itemize}
        \item Хранилища ключей и значений 
        
        \begin{itemize}
            \item Поддерживают высокую разделяемость и обеспечивают беспрецендентное горизонтальное масштабирование 
            \item Игровые, рекламные прилоежния и приложения IoT (Amazon DynamoDB, Redis, Riak)
        \end{itemize}
        
        \item Колоночные
        
        \begin{itemize}
            \item Данные хранятся не по строкам, а по столбцам 
            \item Хорошо подходят для BigData (Hbase, Clickhouse, Vertica)
        \end{itemize}

        \item Документоориентированные 
        
        \begin{itemize}
            \item Хранение коллекций документов с произвольным набором атрибутов (полей)
            \item Каталоги, пользовательские профили и системы управления контентом, где каждый документ уникален и изменяется со временем (CouchDB, Couchbase, MongoDB)
        \end{itemize}

        \item Графовые
        
        \begin{itemize}
            \item Упор на установление произвольных связей между данными 
            \item Социальные сети, сервисы рекомендаций, системы выявления мошенничества и графы знаний (OrientDB, Neo4j)
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{center}
    \begin{tabular}{|m{7.5em}|m{16em}|m{16em}|}
        \hline
        Параметр & Реляционные (SQL) & NoSQL \\
        \hline
        Подходящие рабочие нагрузки & OLTP и OLAP & Приложения с низкой задержкой доступа к данным \\
        \hline
        Модель данных & Нормализованная реляционная модель обеспечивает целостность ссылочных данных в отношениях между таблицами & Предоставляют разнообразные модели данных, оптимизированные для высокой производительности и масштабируемости \\ 
        \hline
        Струткура & Жесткая схема: таблицы (строки, столбцы) & Гибкие модели: документы, ключ-значение, графы, колоночные \\
        \hline
        Изменение схемы & Требует ALTER TABLE, миграции & Гибкость (документы без фиксированной схемы) \\
        \hline
        Типы данных & Строгая типизация & Диинамические (JSON, BLOB и другие) \\
        \hline
        Связи & JOIN, внешние ключи, ACID-транзакции & Часто денормализация, ссылки или вложенные данные \\
        \hline
        Производительность & Зависит от дисковой подсистемы. Требуется оптимизация запросов, индексов и струткур таблицы & Зависит от размера кластера базового аппаратного обеспечения, задержки сети и вызывающего приложения \\ 
        \hline
        Чтение/запись & Быстрые сложные запросы (OLTP), но JOIN могут замедлять & Высокая скорость для простых операция (ключ-значение) \\
        \hline
        Оптимизация & Индексы, нормализация & Денормализация, распределенные вычисления \\
        \hline
        Масштабирование & Масштабируются путем увеличения вычислительных возможностей аппаратного обеспечения или добавления отдельных копий для рабочих нагрузок чтения & Поддерживают высокую разделяемость благодаря шаблонам доступа с возможностью масштабирования на основе распределенной архитектуры \\
        \hline
        Горизонтальное & Сложно (шардинг требует усилий) & Оптмиизировано (например, Cassandra, DynamoDB) \\
        \hline
        Вертикальное & Стандартный подход (увеличение сервера) & Возможно, но реже используется \\
        \hline
    \end{tabular}
\end{center}

\newpage

\subsection{Классификация баз данных}

\begin{nota}{Классификация БД}
    \begin{itemize}
        \item Классификация БД по характеру организации данных 
        
        \begin{itemize}
            \item Неструктурированные 
            
            БД, хранят данные в виде обычного текста или гипертекстовой разметки 

            \begin{itemize}
                \item рпоще зафиксировать (как есть)
                \item Очень трудно искать конкретные данные, поскольку они не структурированы 
                \item Очень трудно анализировать, поскольку данных как правило качественные (семантические)
            \end{itemize}

            \item Структурированные 
            
            БД, хранящие данные в организованном виде в отформатированном хранилище

            \begin{itemize}
                \item Требуют предварительного проектирования и описания структуры БД
                \item Только после этого БД такого типа могут быть заполнены данными 
                \item Очень простой поиск и нахождение данных в базе данных или наборе данных 
                \item Очень легко анализировать данные, поскольку они как правило количественные
            \end{itemize}
        \end{itemize}

        \item Классификация БД по характеру хранимой информации 
        
        \begin{itemize}
            \item Документальные
            
            \begin{itemize}
                \item Предназначены для хранения слабо структурированных данных. Единицей хранения является документ, заданный конечным (но не фиксированным) набором полей в общем случае произвольной длины. Значение поля может иметь сложную структуру и зависеть от контекста использования 
                \item Пользователю в ответ на его запрос выдается либо ссылка на документ, либо сам документ, в котором он может найти интересующую информацию
                \item Использование: гипертекстовые документы в сети Интернет
                \item Информационно-справочные или информационно-поисковые системы 
            \end{itemize}
            \item Фактографические
            
            \begin{itemize}
                \item Ориентированы на хранение хорошо структурированных данных. Единицей информации служит описание факта конечным, четко определенным множеством свойств. Каждое свойство факта (объекта) имеет атомарное значение, которое не зависит от контекста использования
                \item Использование: БД оперативной обработки транзакций (OLTP) -- операционные БД, БД оперативной аналитической обработки (OLAP) -- хранилища данных (Data Warehouse)
            \end{itemize}
        \end{itemize}

        \item Классификация БД и СУБД по структуре организации данных 
        
        Структурированные БД различаются по типу используемой модели представления данных 

        \begin{itemize}
            \item Сетевые
            \item Иерархические
            \item Реляционные
            \item Многомерные 
            \item Объектно-ориентированные 
        \end{itemize}
    \end{itemize}
\end{nota}

\begin{defin}{Модель представления данных}
    Модель данных -- интегрированный набор понятий для описания и обработки данных, связей между ними и ограничений, накладываемых на данные в рамках предметной области 

    Модель данных можно рассматривать как сочетание трех компонентов:

    \begin{itemize}
        \item Структурная часть -- набор правил, по которым может быть построена БД 
        \item Управляющая часть -- определяет типы допустимых операций с данными: для обновления и извллечения данных, для изменения структуры данных 
        \item Набор ограничений (необязательный) для поддержки целостности данных, гарантирующих корректность используемых данных (полноту, непротиворечивость и адекватное отражение предметной области)
    \end{itemize}
\end{defin}

\begin{defin}{Иерархическая модель данных}
    Иерархическая модель данных -- это модель данных, где используется представление БД в виде древовидной (иерархической) структуры, состоящей из объектов (данных) различных уровней -- родителей-потомков 

    В иерархической модели узел может иметь только одного родителя

    \begin{itemize}
        \item Самый верхний узел называется корневым узлом 
        \item Все узлы дерева, за исключением корневого, должны иметь родительский узел 
        \item Связи между отдельными узлами дерева отражаются с помощью направленных ребер графа -- от родителя к ребенку
    \end{itemize}
\end{defin}

\begin{defin}{Сетевая модель данных}
    Для описания сетевой модели данных используют понятия "запись"\ и "связь"\ 

    Связь определяется для двух записей: предка и потомка 

    В сетевой модели данных запись-потомок может иметь произвольное число записей-предков 

    В сетевой структуре каждый элемент может быть связан с любым другим элементом 

    Сетевые базы данных подобны иерархическим, за исключением того, что в них имеются указатели в обоих направлениях, которые соединяют родственную информацию 

    Несмотря на то, что эта модель решает некоторые проблемы, связанные с иерархической моделью, выполнение простых запросов остается достаточно сложным процессом 

    Также, поскольку логика процедуры выборки данных зависит от физической организации этих данных, то эта модель не является полностью независимой от приложения. Другими словаи, если необходимо изменить структуру данных, то нужно изменить и приложение 
\end{defin}

\begin{defin}{Реляционная модель данных}
    Эта модель данных основана на понятии математических отошений (relation)

    В реляционной модели данные представлены в виде плоских таблиц, связанных между собой. Необходимо помнить, что таблица есть понятие нестрогое и часто означает не отношение как абстрактное понятие, а визуальное представление отношения на бумаге или экране. В частности -- таблицы обычно предполагают упорядоченное хранение данных, в то время как отношения -- не обладают этой характеристикой 

    Между отношениями поддерживаются связи один-к-одному или один-ко-многим 
\end{defin}

\begin{defin}{Многомерная модель данных}
    Данные представлены в виде многомерного куба (массива). Измерение (атрибут в реляционной модели) -- размерность куба. Факт (агрегированная числовая характеристика) -- содержимое ячейки 

    Агрегаты по всем срезам куба высчитываются один раз и хранятся в базе 
\end{defin}

\begin{defin}{Объектно-ориентированная модель данных}
    Данные представлены в виде классов и относящихся к ним объектов 

    \begin{itemize}
        \item Класс -- тип объекта 
        \item Атрибут -- свойство объекта 
        \item Метод -- операция над объектом 
    \end{itemize}

    Инкапсуляция структурного и функционального описания объектов 

    Наследуемость внешних свойств объектов на основе соотношения "класс-подкласс"\
\end{defin}

\newpage 

\subsection{Классификация СУБД}

\begin{defin}{Словарь данных}
    Словарь данных -- набор доступных для выборки всем пользователям базы данных системных таблиц, в которых хранятся метаданные (данные о данных)
\end{defin}

\begin{nota}{Классификация СУБД}
    \begin{itemize}
        \item Классификация по количеству пользователей 
        
        \begin{itemize}
            \item Однопользовательские 
            
            \begin{itemize}
                \item Реализуются на автономном ПК без использования сетей связи 
                \item Рассчитаны на работу одного пользователя или группы пользователей, разделяющих по времени одно рабочее место 
                \item Настольные или локальные СУБД 
            \end{itemize}

            \item Многопользовательские 
            
            \begin{itemize}
                \item Ориентированы на коллективное использование информации 
                \item Строятся на базе локальной вычислительной сети 
                \item Могут быть распределены по нескольким узлам (хостам)
            \end{itemize}
        \end{itemize}

        \item Классификация по степени распределенности
        
        \begin{itemize}
            \item Локальные СУБД -- все части размещаются на одном компьютере 
            \item Распределенные СУБД -- части СУБД могут размещаться не только на одном, но на двух и более компьютерах 
            
            \begin{itemize}
                \item Файл-серверные
                \item Клиент-серверные 
                
                \begin{itemize}
                    \item Двухзвенные (СУБД и БД, клиентские приложения)
                    \item Многозвенные (СУБД и БД, сервер приложений, клиентские приложения)
                \end{itemize}
            \end{itemize}
        \end{itemize}
        \item Классификация по способу доступа к БД 
    \end{itemize}
\end{nota}

\begin{nota}{Недостатки файл-серверной архитектуры}
    СУБД не располагает информацией о том, что происходит на компьютере где хранятся данные:

    \begin{itemize}
        \item Невозможно считать из БД только ту часть данных, которые запрашивает пользователь -- считывается файл целиком (блокировка файла) 
        \item Большой объем сетевого трафика (передача по сети множества блоков и файлов, необходимых приложению)
        \item Узкий спект операций манипулирования с данными, определяемый только файловыми командами 
        \item Отсутствие адекватных средств безопасности доступа к данным (защита только на уровне файловой системы)
        \item Недостаточно развитый аппарат транзакций служит потенциальным источником ошибок в плане нарушения смысловой и ссылочной целостности информации при одновременном внесении изменений в одну и ту же запись 
    \end{itemize}
\end{nota}

\begin{defin}{Архитектура клиент-сервер (двухзвенная)}
    На сервере: база данных, серверная часть СУБД -- взаимодействует с БД, обеспечивая выполнение запросов клиентской части 

    На клиенте: прикладные программы, клиентская часть СУБД -- обеспечивает взаимодействие с пользователем и формирование запросов к БД и передача их на сервер

    Преимущества:

    \begin{itemize}
        \item СУБД располагает информацией о наборе файлов БД
        \item Обеспечение разграничения доступа к данным нескольких пользователей 
        \item Считывание только необходимой пользователю информации из файла (блокировка блока данных)
        \item Обеспечивает корректную параллельную раоту всех пользователей с единой БД 
    \end{itemize}

    Недостатки: 

    \begin{itemize}
        \item Очень большая загрузка на сервер, так как он обслуживает множество клиентов и выполняет всю основную обработку данных 
        \item Нагрузка с обработкой полученных данных дублируется на клиентские хосты 
    \end{itemize}
\end{defin}

\begin{defin}{Архитектура клиент-сервер (трехзвенная)}
    Схема: тонкий клиент $\to$ сервер приложений $\to$ сервер базы данных 

    В функции клиентской части (тонкий клиент) входи только интерактивное взаимодействие с пользователем 

    Вся логика обработки данных (прикладные программы) вынесена на сервер приложений, который и обеспечивает формирование запросов к БД, передаваемых на выполнение серверу БД 

    Сервер приложений может являться специализированной программой или обычным web-сервером 

    Преимущества: 

    \begin{itemize}
        \item Снижается нагрузка на сервер БД -- он занимается исключительно функциями СУБД 
        \item При изменении бизнес-логики нет необходимости изменять клиенсткие приложения 
        \item Максимально снижаются требования к аппаратуре пользователей 
        \item Данная модель обладает большей гибкостью, чем двухуровневые модели 
    \end{itemize}

    Недостатки:

    \begin{itemize}
        \item Более высокие затраты ресурсов компьютеров на обмен информацией между компонентами приложений по сравнению с двухуровневыми моделями 
    \end{itemize}
\end{defin}

\begin{defin}{Встраиваемые СУБД}
    Встаиваемая СУБД -- поставляется как составная часть некоторого программного продукта, не требующая процедуры самостоятельной установки

    Предназначена для локального хранения данных своего приложения и не рассчитана на коллективное использование в сети 

    Физически чаще всего реализуется в виде подключаемой библиотеки 

    Доступ к данным со стороны приложения может происходить через язык запросов либо через специальные программные интерфейсы 
\end{defin}

\newpage

\subsection{Аспект обработки реляционной модели}

\begin{nota}{Математические аппараты для манипулирования данными}
    Виды:

    \begin{itemize}
        \item Реляционная алгебра -- основана на теории множеств. Описывает порядок выполнения операций, позволяющих из исходных выражений получить результат 
        \item Реляционное исчисление -- основано на логике предикатор первого порядка. Описывает результат в терминах исходных отношений 
    \end{itemize}

    Свойство замкнутости операций на множестве отношений. Выражения реляционной алгебры и формулы реляционного исчисления определяются над отношениями реляционных БД и результатом вычисления также являются отношения 

    В современных РСУБД не используется в чистом виде ни реляционная алгебра, ни реляционное исчисление. Фактическим стандартом доступа к реляционным данным стал язык SQL (Structured Query Language), который представляет собой смесь операторов реляционной алгебры и выражений реляционного исчисления, использующий синтакси, близкий к фразам английского языка и расширенный лополнительными отсутствующими в упомянутых аппаратах
\end{nota}

\begin{defin}{Реляционная алгебра (РА)}
    Реляционная алгебра -- это формальный язык операций над отношениями (таблицами), включающий SQL -- декларативный язык запросов, который включает не только операции РА, но и дополнительные конструкции (агрегацию, рекурсию, модификацию данных и др.)

    Вывод: классическая реляционная алгебра и базовый SQL (без агрегации, рекурсии, оконных функци итд) эквивалентны по выразительной силе в рамках запросов к базе данных. Однако SQL строго мощнее, если учитывать все его возможности (например, рекурсивные запросы, агрегацию, модификацию данных)

    Операции реляционной алгебры:

    \begin{itemize}
        \item Теоретико-множественные
        
        \begin{itemize}
            \item Объединение отношений 
            \item Пересечение отношений
            \item Вычитание отношений 
            \item Декартово произведение отношений 
        \end{itemize}

        \item Специальный 
        
        \begin{itemize}
            \item Выборка (ограничение) отношений 
            \item Проекция отношения
            \item Соединение отношений 
            \item Деление отношения 
        \end{itemize}

        \item Дополнительные 
        
        \begin{itemize}
            \item Присваивание (сохранение результатов вычисления)
            \item Переименование атрибутов отношения 
        \end{itemize}
    \end{itemize}
\end{defin}

\begin{nota}{Совместимость по типу}
    Некоторые реляционные операции требуют, чтобы отношения были совместимы по типу 

    Отношения являются совместимыми по типу, если их схемы идентичны 

    Отношения имеют одно и то же множество имен атрибутов, т.е. для любого атрибута в одном отношении найдется атрибут с таким же именем в другом отношении 

    Атрибуты с одинаковыми именами определены на одних и тех же доменах 

    Степени схем отношений (количество атрибутов) совпадают 
\end{nota}

\begin{defin}{Объединение отношений}
    Объединением двух совместимых по типу отношений $A$ и $B$ называется отношение $S$ с той же схемой, что и у отношений $A$ и $B$, и состоящее из кортежей, принадлежащих или $A$, или $B$, или обоим отношениями

    Синтаксис: A UNION B или A $\cup$ B

    \begin{Remark}{}
        Объединение, как и любое отношение, не может содержать одинаковых кортежей 

        Если некоторый кортеж входит и в отношение A, и в отношение B, то в объединение он входит один раз
    \end{Remark}
\end{defin}

\begin{defin}{Вычитание отношений}
    Вычитанием двух совместимых по типу отношений A и B называется отношение S с той же схемой, что и у отношений A и B, и состоящее из кортежей, принадлежащих отношению A и не принадлежащих отношению B 

    Синтаксис: A EXCEPT B или A $\setminus$ B
\end{defin}

\begin{defin}{Пересечение отношений}
    Пересечением двух совместимых по типу отношений A и B называется отношение S с той же схемой, что и у отношений A и B, и состоящее из кортежей, принадлежащих одновременно обоим отношениям 

    Синтаксис: A INTERSECT B или A $\cap$ B 

    \begin{Remark}{}
        Пересечение может быть выражено через операцию вычитания: $A \cap B = A \setminus (A \setminus B)$
    \end{Remark}
\end{defin}

\begin{defin}{Декартово произведение отношений}
    Декартовым произведением двух отношений $A = (A_1, A_2, \ldots A_n)$ и $B = (B_1, B_2 \ldots B_m)$ называется отношение S, со схемой, состоящей из атрибутов отношений $A$ и $B$: $(A_1, A_2 \ldots A_n, B_1, B_2 \ldots B_m)$ и являющееся результатом конкатенации (сцепления) каждого кортежа из отношения $A$ с каждый кортежем из отношения $B$. В результате получаем набор кортежей $(a_1, a_2 \ldots a_n, b_1, b_2 \ldots b_m)$, таких, что $(a_1 \ldots a_n) \in A$, а $(b_1 \ldots b_m) \in B$

    Синтаксис: A CROSS JOIN B или $A * B$

    \begin{Remark}{}
        Мощность произведения равен произведению мощностей отношений A и B 

        Если в отношениях A и B имеются атрибуты с одинаковыми наименованиями, то перед выполнением операции декартового произвдеения такие атрибуты необходимо переименовать 
    \end{Remark}
\end{defin}

\begin{defin}{Выборка (ограничение) отношений}
    Выборкой (ограничением) называется подмножество кортежей отношения R, удовлетворяющих определенному условию (предикату)

    Результат выборки -- горизонтальный срез отношения по некоторому условию

    Предикат -- логическое выражение, в которое могут входить атрибуты отношения R и/или скалярные выражения 

    Синтаксис: R WHERE или $\sigma$ R
\end{defin}

\begin{defin}{Проекция отношения}
    Проекцией называется вертикальное подмножество кортежей отношения R, создаваемое посредством извлечения значений указанных атрибутов $A_1 \ldots A_n$ отношения 

    Результат проекции -- вертикальный срез отношения, в котором удалены все возникшие при этом дубликаты кортежей 

    Синтаксис: $R[A_1 \ldots A_n]$ или $\prod_{A_1 \ldots A_n} R$
\end{defin}

\begin{defin}{Соединение отношений}
    $\theta$-соединение (тэта-соединение) -- определяет отношение S, которое содержит кортежи из декартового произведения отношений A и B, удовлетворяющих предикату $\theta$

    Синтаксис: (A JOIN B) ON $\theta$

    \begin{Remark}{Частные случаи}
        \begin{itemize}
            \item Экви-соединение -- предикат содержит только оператор равенства 
            \item Естественное соединение -- эквисоединение отношений A и B, выполненное по всем общим атрибутам, из результатов которого исключается по одному экземпляру каждого общего атрибута 
            \item Левое внешнее соединение -- соединение, при котором кортежи отношения A, не имеющие совпадающих значений в общих атрибутах отношения B, также включаются в общее отношение 
        \end{itemize}
    \end{Remark}
\end{defin}

\begin{defin}{Деление}
    Пусть даны отношения $A(X_1 \ldots X_n, Y_1 \ldots Y_p)$ и $B(Y_1 \ldots Y_p)$, причем атрибуты $(Y_1 \ldots Y_p)$ -- общие для двух отношений 

    Результатом деления отношения A на B является отношение со схемой $S(X_1 \ldots X_n)$, содержащее множество кортежей $(x_1 \ldots x_n)$, таких, что для всех кортежей $(y_1 \ldots y_p) \in B$ в отношении A найдется кортеж $(x_1 \ldots x_n, y_1 \ldots y_p)$

    Отношение A выступает в роли делимого, отношение B выступает в роли делителя 

    Все атрибуты отношения B должны входить в состав схемы отношения A 

    Синтаксис: A DIVIDE BY B или A $\div$ B

    \begin{Remark}{}
        Деление может быть выражено через операции декартова произведения и вычитания 

        Типичные запросы, реализуемые с помощью операции деления, обычно в своей формулировке имеют слово все 
    \end{Remark}
\end{defin}

\begin{Example}{}
    \begin{enumerate}
        \item Получить имена поставщиков, поставляющих деталь номер 2:
        
        ((DP JOIN P) WHERE DNUM=2)[PNAME]

        \item Получить имена поставщиков, поставляющих по крайней мере одну гайку 
        
        (((D JOIN DP) JOIN P) WHERE DNAME=Гайка)[PNAME]
        (((D WHERE DNAME=Гайка) JOIN DP) JOIN P)[PNAME]

        \item Получить имена поставщиков, поставляющих все детали 
        
        ((DP[PNUM,DNUM] DIVIDE BY D[DNUM]) JOIN P)[PNAME]
    \end{enumerate}
\end{Example}

\newpage

\subsection{Типы данных}

\begin{defin}{PostreSQL и типы данных}
    SQL -- язык со строгой типизацией. Каждый элемент данных имеет некоторый тип, определяющий его поведение и допустимое использование 

    PostreSQL наделен расширяемой системой типов, более универсальной и гибкой по сранвению с другими реализациями SQL 
\end{defin}

\begin{nota}{Типы данных}
    \begin{itemize}
        \item Символьные 
        \item Числовые 
        \item Дата и время 
        \item Логические 
        \item Двоичные 
        \item Специальные 
    \end{itemize}
\end{nota}

\begin{defin}{Символьные данные}
    varchar(n), char(n), text 

    Константные зачения. Последовательность символов, заключенная в апострофы. Две строковые константы, разделенные пробельными символами и минимум одним переводом строки, объединяются в одну 

    \begin{itemize}
        \item Константы со спецпоследовательностями в стиле С 
        
        Начинаются с буквы Е (заглавной или строчной)

        \item Строковые константы со спецпоследовательностями Unicode 
        
        Позволяют включать в строки символы Unicode по их кодам 

        Начинается с U\& (строчная или заглавная U и амперсанд)

        Символы Unicode можно записывать двумя способами:

        \begin{itemize}
            \item $\backslash$ и код символа из четырех шестнадцатеричных цифр 
            \item $\backslash+$ и код символа из шести шестнадцатеричных цифр
        \end{itemize}

        \item Строковые константы, заключенные в доллары 
        
        Используются для работы со строками, содержащими много апострофов или обратных косых черт. Позволяют избежать необходимости зеркалирования служебных символов. Делают строки более читабельными. Обрамляются \$[тэг]\$
    \end{itemize}
\end{defin}

\begin{defin}{Точные числовые данные}
    Целочисленные типы -- smallint (int2), integer (int4), bigint (int8)

    Числа фиксированной точности -- numeric (precision, scale) и decimal (precision, scale)
\end{defin}

\begin{defin}{Числовые данные с плавающей точкой}
    real, double precision и float(p)

    Поддерживают специальные значения Infinity, -Infinity и NaN

    Если точность вводимого числа выше допустимой -- будет выполняться округление значения. При вводе слишком большого или очень маленького значения будет генерироваться ошибка 

    Внимание: сравнение двух чисел с плавающей точкой на предмет равенства их значений может привести к неожиданным результатам 
\end{defin}

\begin{defin}{опследовательные типы}
    serial (int4), bigserial (int8) и msallserial (int2)

    Реализованы как удобная замена целой группы SQL-команд: создание объекта SEQUENCE -- генератор уникальных целых чисел, генерация и получение значений последовательности 

    Часто используются в качестве значений суррогатного первичного ключа (Primary Key)

    Нет неоюходимости указывать явное значение для вставки в поле РК 
\end{defin}

\begin{nota}{Функции для работы с последовательностями}
    \begin{center}
        \begin{tabular}{|m{7em}|m{4em}|m{25em}|}
            \hline
            Функция & Тип результата & Описание \\ 
            \hline
            currval('name') & bigint & Возвращает последнее сгенерированное значение указанной последовательности (которое было возвращено при последнем вызове функции nextval) \\
            \hline
            lastval() & bigint & Возвращает последнее сгенерированное значение любой последовательности (которое было возвращено при последнем вызове функции nextval) \\
            \hline 
            nextval('name') & bigint & Генерит и возвращает новое значение последовательности \\ 
            \hline
            setval('name', bigint) & bigint & Устанавливает текущее значение последовательности \\
            \hline
            setval('name', bigint, boolean) & bigint & Устанавливает текущее значение последовательности и флаг is-called, указывающий на то, что это значение уже использовалось \\
            \hline
        \end{tabular}
    \end{center}
\end{nota}

\begin{defin}{Дата и время}
    date, time и time with time zone (timetz)

    Даты обрабатываются в соответствии с григорианским календарем

    time хранит время внутри суток. time with time zone хранит время с учетом смещения, соответствующего часовому поясу

    При вводе значений их нужно заключать в одинарные кавычки, как и текстовые строки
\end{defin}

\begin{defin}{Временная метка (интегральный тип)}
    timestamp, timestamp with time zone (timestamptz)

    Получается в результате объединения типов даты и времени 

    Оба типа занимают 8 байтов 

    Значения типа timestamptz хранятся приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся к часовому поясу пользователя 
\end{defin}

\begin{defin}{Тип interval}
    Представляет продолжительность отрезка времени 

    Формат: quantity unit [quantity unit ...] direction

    Стандарт ISO 8601: P[yyyy-mm-dd][Thh:mm:ss]

    Значение типа interval можно получить при вычитании одной временной метки из другой 
\end{defin}

\begin{nota}{Операторы даты/времени}
    \begin{itemize}
        \item date +/- integer -- добавляет/вычитает к дате заданное число дней 
        \item date +/- interval -- добавляет/вычитает к дате интервал 
        \item date +/- time -- добавляет/вычитает к дате время 
        \item interval +/- interval -- складывает/вычисляет интервалы 
        \item timestamp +/- interval -- добавляет/вычитает к метке времени интервал 
        \item date - date -- возвращает разницу между датами в днях 
        \item timestamp - timestamp -- вычитает из одной отметки времени другую (преобразуя 24-часовые интервалы в дни)
    \end{itemize}
\end{nota}

\begin{defin}{Логический тип}
    boolean

    Может иметь три состояния: true, false, NULL. Реализует трехзначную логику 
\end{defin}

\begin{defin}{Двоичные типы данных}
    bytea

    Позволяют хранить байты с кодом 0 и другими непечатаемыми значениями (значения вне десятичного диапазона 32..126)

    В операциях с двоичными строками обрабатываются байты в чистом виде 

    Поддерживает два формата ввода и вывода (параметр bytea-output):

    \begin{itemize}
        \item hex (шестнадцатеричный) -- '$\backslash x$ коды символов в 16-ой системе'
        \item escape (спецпоследовательностей) -- '$\backslash$коды символов в 8-ой системе'
    \end{itemize}
\end{defin}

\begin{nota}{Приведение типов}
    Приведение типов в PostreSQL -- это осуществление преобразования одного типа информации в другой

    Для приведения типов данных в PostreSQL используется: функция CAST, выражение::тип, тип выражения 

    Неявные преобразования, производимые PostreSQL, могут влиять на результат запроса
\end{nota}

\end{document}